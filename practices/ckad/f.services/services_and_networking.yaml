# Create a pod with image nginx called nginx and expose its port 80
# k run nginx --image=nginx --port=80 --restart=Never -o yaml --expose # --expose æ˜¯æœ¬é¡Œé‡è¦åƒæ•¸

# Confirm that ClusterIP has been created. Also check endpoints
# k get svc nginx
# k get ep # é‡è¦æŒ‡ä»¤
# æŽ¥è‘—å­˜ minikube ç®¡ç†çš„æœå‹™ï¼š
# docker context use default
# minikube service nginx --url
# https://minikube.sigs.k8s.io/docs/handbook/accessing/
# æŽ¥è‘— minikube æœƒè·‘å‡ºé¡žä¼¼ä¸‹é¢çš„è¨Šæ¯ï¼š
# $ docker context use default
# default
# Current context is now "default"
# $ minikube service nginx --url
# ðŸ˜¿  service default/nginx has no node port
# â—  Services [default/nginx] have type "ClusterIP" not meant to be exposed, however for local development minikube allows you to access this !
# http://127.0.0.1:4924
# â—  Because you are using a Docker driver on windows, the terminal needs to be open to run it.
# åªè¦å†æ‰“ 127.0.0.1:4924 å³å¯å‘¼å«æœå‹™

# Get service's ClusterIP, create a temp busybox pod and 'hit' that IP with wget
# k get svc nginx
# k run busybox --image=busybox --restart=Never --rm -it -- /bin/sh
# é€²åŽ»å¾Œ wget 10.111.150.44:80

# Convert the ClusterIP to NodePort for the same service and find the NodePort port. Hit service using Node's IP.
# Delete the service and the pod at the end.
# k edit svc nginx
# æŠŠæ–‡ä»¶èª¿æ•´æˆä¸‹é¢çš„æ¨£å­ï¼Œèª¿æ•´å®Œå­˜æª”ã€‚
# k get svc nginx
# k get po nginx -o wide # æŸ¥å…¶æ‰€åœ¨çš„ç¯€é»žåç¨±
# ä½¿ç”¨ minikube æ™‚ï¼Œå¯ä»¥é€éŽ minikube service --url æŸ¥æœå‹™ä½ç½®ï¼Œç„¶å¾Œå†å¾žæœ¬åœ°æ‰“ç‰¹å®šçš„åŸ è™Ÿå¦‚ 127.0.0.1:4988 

apiVersion: v1
kind: Service
metadata:
  creationTimestamp: "2025-01-16T16:41:51Z"
  name: nginx
  namespace: default
  resourceVersion: "7717"
  uid: cfdfc6b0-6dad-4299-b1ab-000eab0f1889
spec:
  clusterIP: 10.111.150.44
  clusterIPs:
  - 10.111.150.44
  internalTrafficPolicy: Cluster
  ipFamilies:
  - IPv4
  ipFamilyPolicy: SingleStack
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    run: nginx
  sessionAffinity: None
  type: NodePort # èª¿æ•´é€™è¡Œ
status:
  loadBalancer: {}

# Create a deployment called foo using image 'dgkanatsios/simpleapp' (a simple server that returns hostname) and 3 replicas. Label it as 'app=foo'.
# Declare that containers in this pod will accept traffic on port 8080 (do NOT create a service yet)
# k create deploy foo --image=dgkanatsios/simpleapp --replicas=3 --dry-run=client -o yaml > deploy.yaml

# Get the pod IPs. Create a temp busybox pod and try hitting them on port 8080

# Create a service that exposes the deployment on port 6262. Verify its existence, check the endpoints

# Create a temp busybox pod and connect via wget to foo service. Verify that each time there's a different hostname returned. Delete deployment and services to cleanup the cluster

# Create an nginx deployment of 2 replicas, expose it via a ClusterIP service on port 80. Create a NetworkPolicy so that only pods with labels 'access: granted' can access the pods in this deployment and apply it
